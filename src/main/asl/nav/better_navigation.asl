/**
There are various types of navigation, each driving their own requirements:
Both types of navigation should call the path finding module.

1. Typical navigation to a specific destination.
    - We want the agent to land on the destination
    - Used when navigating to a specific meeting point

2. Navigation beside a destination
    - This is useful when we want to navigate TO other "things"
    - i.e. we want to navigate BESIDE a dispenser, and not on it.
    - i.e. We want to navigate BESIDE a block drop-off point

================
Additional Notes:
- Navigation plans should call the movement component.
- Navigation plans should invoke path finding on every cycle (??) to ensure the current path
    is up-to-date with the perceptions.
- Navigation plans should monitor for failed_path, as it may signify an issue with path finding, or it
    could potentially be that we are hitting a forbidden area with a block?

============
Assumptions:
    - Path finding does not consider any attached blocks, so it is possible that the path finding may
      find a path that is impossible to traverse. This currently is handled when we use movement.asl. When
      the agent attempts to move, it will try to rotate itself to traverse the path generated by path finding.
      If it cannot traverse, even after rotating, the action plan will fail. This failure will bubble up to
      the navigation plans.
**/

getSearchedThing(TYPE, DETAILS, relative(X, Y))
    :-  hasThingPerception(X, Y, TYPE, DETAILS) &
        xyToDirection(X, Y, _).

// Checks if an agent is at an absolute X, Y position
isAtLocation(X, Y)
    :-  .ground(X) & .ground(Y) & isCurrentLocation(absolute(X, Y)).

generateThingDest(TYPE, DETAILS, DEST)
    :-  eis.internal.navigation_thing(TYPE, DETAILS, DEST).

generatePath(X, Y, FIRST, RESULT)
    :-  navigationPath(X, Y, [FIRST | PATH], RESULT).

+!stepToDestination(X, Y)
    :   isAtLocation(X, Y)
    <-  .print("Agent has arrived at destination: [", X, ", ", Y, "]").

+!stepToDestination(X, Y)
    :   not(isAtLocation(X, Y)) &
        generatePath(X, Y, DIR, success)
    <-  .print("Stepping: ", DIR);
        !move(DIR).

+!stepToDestination(X, Y)
    :   not(isAtLocation(X, Y)) &
        generatePath(X, Y, DIR, FAIL) &
        FAIL \== success
    <-  .print("Failed to generate the path: ", FAIL);
        .fail(navigateError(FAIL)).

+!navigateToDestination(X, Y)
    :   not(isAtLocation(X, Y))
    <-  .print("Navigating: ", X, ", ", Y);
        !stepToDestination(X, Y);
        !navigateToDestination(X, Y).

+!navigateToDestination(X, Y)
    :   isAtLocation(X, Y)
    <-  .print("Arrived at the destination: ", X, Y).

/** Search for Thing Perception **/
+!searchForThing(TYPE, DETAILS, REL)
    :   generateThingDest(TYPE, DETAILS, DEST) &
        (location(X, Y) = DEST) &
        not(.ground(REL))
    <-  .print("Found ", TYPE, ". Destination: ", DEST);
        !navigateToDestination(X, Y);
        ?getSearchedThing(TYPE, DETAILS, REL).

+!searchForThing(TYPE, DETAILS, REL)
    :   not(generateThingDest(TYPE, DETAILS, _))
    <-  .print("Could not find thing: ", TYPE, ", ", DETAILS);
        !explore;
        !searchForThing(TYPE, DETAILS, LOC).


//-!searchForThing(TYPE, DETAILS, LOC)[error(E), moveError(failed_path)]
//    <-  .print("Move Error Occurred. Trying again.");
//        !searchForThing(TYPE, DETAILS, LOC).
